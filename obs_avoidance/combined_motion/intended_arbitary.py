import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline
from operators import Y
from ref import Ref_path
#this is supposed to be the og trajectory  or intended traj generated by arbitary planners barely avoiding collision
#these are supposed to be real time obstacle avoidance but for sake of testing emergency traj only
#simple cubic interpolations, no control inputs 
class intended_traj:
    def __init__(self, points):
        self.start = np.array(points[0])
        self.goal = np.array(points[1])

        # Time points corresponding to the waypoints (normalized between 0 and 1)
        # self.time_points = np.linspace(0, 1, len(self.waypoints))

        # Generate `t` points using np.linspace()
        self.t = np.linspace(0, 5, 100)

    def kinematic_bicycle_model(self,state, control):
        x, y, theta = state
        v, omega = control
        dt = 0.1
        x_next = x + v * np.cos(theta) * dt
        y_next = y + v * np.sin(theta) * dt
        theta_next = theta + omega * dt
        return np.array([x_next, y_next, theta_next])


    def generate_path(self):
        # Perform cubic spline interpolation to get x(t) and y(t) values
        # x_spline = CubicSpline(self.time_points, self.waypoints[:, 0])
        # y_spline = CubicSpline(self.time_points, self.waypoints[:, 1])
        # x_interpolated = x_spline(self.t / 5)
        # y_interpolated = y_spline(self.t / 5)
        # Generate smooth control inputs (constant velocity and zero angular velocity)
        num_steps = 100
        T = 5
        v = np.linspace(0, np.linalg.norm(self.goal - self.start[:2]) / T, num_steps-1)
        omega = np.zeros(num_steps-1) #NO ROTATION
        controls = np.vstack((v, omega))

        # Simulate the trajectory
        trajectory = [self.start]
        current_state = self.start
        for control in controls.T:
            current_state = self.kinematic_bicycle_model(current_state, control)
            trajectory.append(current_state)
        trajectory = np.array(trajectory)
        return trajectory[:, 0], trajectory[:, 1]
    
    def orientation_at_point(self, x, y):
        return np.arctan2(y[1:] - y[:-1], x[1:] - x[:-1])
    
    def orientation(self):
        # Calculate the orientation (a) at each point on the reference path
        x_traj, y_traj = self.generate_path()
        a_traj = self.orientation_at_point(x_traj, y_traj)

        # Convert angles to degrees for better visualization
        a_traj_degrees = np.degrees(a_traj)
        return a_traj_degrees

    def generate_curvilinear_path(self):
        x_traj, y_traj = self.generate_path()
        
        curvilinear_coords = []
        for x, y in zip(x_traj, y_traj):
            s, d = Y(x, y)
            curvilinear_coords.append((s, d))
        curvilinear_coords = np.array(curvilinear_coords)
        return curvilinear_coords

    def state(self):
        ##
        T = Ref_path([0, 10], [100, 10], 5)
        x_traj, y_traj = self.generate_path()
        curvilinear_coords = self.generate_curvilinear_path()
        s, d = curvilinear_coords[:, 0] , curvilinear_coords[:, 1] 
        ##CARTESIAN v, a ,j 
        dt = self.t[1] - self.t[0]  # Time step

        vx = np.gradient(x_traj, dt) #Gradient causes noise and error
        vy = np.gradient(y_traj, dt) #Gradient causes noise and error
        v = np.sqrt(vx**2 + vy**2)

        ax = np.gradient(vx, dt) #Gradient causes noise and error
        ay = np.gradient(vy, dt)
        a = np.sqrt(ax**2 + ay**2)

        jx = np.gradient(ax, dt) #Gradient causes noise and error
        jy = np.gradient(ay, dt)
        j = np.sqrt(jx**2 + jy**2)

        snapx = np.gradient(jx, dt) #Gradient causes noise and error
        snapy = np.gradient(jy, dt)
        snap = np.sqrt(snapx**2 + snapy**2)

        ##curvilinear s,d convert in speed and direction and take componenets
        alpha_points = T.orientation()
        theta_points_v = self.orientation_at_point(vx,vy)
        theta_points_v = np.degrees(theta_points_v)
        vs_points = v[1:]* np.cos(theta_points_v - alpha_points)
        vd_points = v[1:] * np.sin(theta_points_v -alpha_points)

        # Calculate as and ad using numerical differentiation
        theta_points_a = self.orientation_at_point(ax,ay)
        theta_points_a = np.degrees(theta_points_a)
        as_points = a[1:] * np.cos(theta_points_a - alpha_points)
        ad_points = a[1:] * np.sin(theta_points_a -alpha_points)\
        
         # Calculate js and jd using numerical differentiation
        theta_points_j = self.orientation_at_point(jx,jy)
        theta_points_j = np.degrees(theta_points_j)
        js_points = j[1:] * np.cos(theta_points_j - alpha_points)
        jd_points = j[1:] * np.sin(theta_points_j -alpha_points)

         # Calculate as and ad using numerical differentiation
        theta_points_snap = self.orientation_at_point(snapx,snapy)
        theta_points_snap = np.degrees(theta_points_snap)
        snaps_points = snap[1:] * np.cos(theta_points_snap - alpha_points)
        snapd_points = snap[1:] * np.sin(theta_points_snap -alpha_points)

        ##find orientation wrt to horizontal
        theta =   self.orientation_at_point(x_traj, y_traj)

        ##find curvature wrt preplanned long traj(optimized)
        # Calculate curvature κ
        a_max = 2
        κ = [np.sqrt(abs((a_max**2 - a_t**2))) /v_t**2 for v_t, a_t in zip(vs_points, as_points)]

        # Calculate rate of curvature κ_dot
        κ_dot = np.gradient(κ,dt)  # Using numpy's gradient function

        # Calculate rate of rate of curvature κ_ddot
        κ_ddot = np.gradient(κ_dot,dt)  # Using numpy's gradient function

        state = zip( x_traj, y_traj,s, vs_points, as_points, js_points, snaps_points,
                 d, theta, κ, κ_dot, κ_ddot)

        return state


    def plot(self):
        x_interpolated, y_interpolated = self.generate_path()
        plt.figure(figsize=(10, 6))
        plt.subplot(2, 1, 1)
        plt.plot(x_interpolated, y_interpolated, label='Smooth Spline Trajectory', color='b')
        plt.scatter(self.goal, self.start[: 2], color='red', label='Waypoints')
        plt.xlabel('X Position')
        plt.ylabel('Y Position')
        plt.legend()
        plt.grid(True)
        '''
        plt.subplot(2, 1, 2)
        a_traj_degrees = self.orientation()
        print(a_traj_degrees)
        #plt.ylim(0,10)
        plt.plot(self.t[:-1], a_traj_degrees, label='Orientation (a)')
        plt.xlabel('Time (s)')
        plt.ylabel('Orientation (degrees)')
        plt.show()
        '''
        # plt.subplot(2, 1, 2)
        # state = self.state()
        # print(state)
        # #plt.ylim(0,10)
        # plt.plot(s, d, label='Curvilinear')
        # plt.xlabel('S')
        # plt.ylabel('D')
        plt.show()

# Tin = intended_traj([(0, 10, 0),(40, 10)])
# Tin.plot()

